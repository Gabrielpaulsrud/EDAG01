        -:    0:Source:intopt.c
        -:    0:Graph:intopt.gcno
        -:    0:Data:intopt.gcda
        -:    0:Runs:1
        -:    1:#include <math.h>
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <string.h>
        -:    5:
        -:    6:// double epsilon = 0.000001;
        -:    7:const double epsilon = 0.000001;
        -:    8:
        -:    9:#define PRINT		0	/* enable/disable prints. */
        -:   10:#define MAIN 0 // Enables main
        -:   11:#if PRINT
        -:   12:#define pr(...)		do { fpr(stderr, __VA_ARGS__); } while (0)
        -:   13:#else
        -:   14:#define pr(...)		/* no effect at all */
        -:   15:#endif
        -:   16:
        -:   17:typedef struct node_t node_t;
        -:   18:typedef struct simplex_t simplex_t;
        -:   19:typedef struct linked_nodes_t linked_nodes_t;
        -:   20:
        -:   21:struct simplex_t {
        -:   22:  int m;
        -:   23:  int n;
        -:   24:  int *var;
        -:   25:  double **a;
        -:   26:  double *b;
        -:   27:  double *c;
        -:   28:  double *x;
        -:   29:  double y;
        -:   30:};
        -:   31:
        -:   32:struct node_t {
        -:   33:  int m;
        -:   34:  int n;
        -:   35:  int k;
        -:   36:  int h;
        -:   37:  double xh;
        -:   38:  double ak;
        -:   39:  double bk;
        -:   40:  double *min;
        -:   41:  double *max;
        -:   42:  double **a;
        -:   43:  double *b;
        -:   44:  double *x;
        -:   45:  double *c;
        -:   46:  double z;
        -:   47:  node_t *next;
        -:   48:};
        -:   49:
        -:   50:struct linked_nodes_t {
        -:   51:  node_t *head;
        -:   52:};
        -:   53:
        -:   54:
        -:   55:void pivot(simplex_t *s, int row, int col);
        -:   56:double xsimplex(int m,
        -:   57:                int n,
        -:   58:                double **a,
        -:   59:                double *b,
        -:   60:                double *c,
        -:   61:                double *x,
        -:   62:                double y,
        -:   63:                int *var,
        -:   64:                int h);
        -:   65:
function push called 1639 returned 100% blocks executed 100%
     1639:   66:void push(linked_nodes_t *h, node_t *p) {
     1639:   67:  p->next = h->head;
     1639:   68:  h->head = p;
     1639:   69:}
        -:   70:
function pop called 1596 returned 100% blocks executed 75%
     1596:   71:node_t *pop(linked_nodes_t *h) {
     1596:   72:  if (h->head == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   73:    return NULL;
        -:   74:  }
     1596:   75:  node_t *p = h->head;
     1596:   76:  h->head = p->next;
     1596:   77:  return p;
        -:   78:}
        -:   79:
function scan_vector called 0 returned 0% blocks executed 0%
    #####:   80:double *scan_vector(double *v, int len) {
        -:   81:  int i;
    #####:   82:  for (i = 0; i < len; i++) {
branch  0 never executed
branch  1 never executed
    #####:   83:    scanf("%lf", &v[i]);
call    0 never executed
        -:   84:  }
    #####:   85:  return v;
        -:   86:}
        -:   87:
function make_matrix called 3158 returned 100% blocks executed 100%
     3158:   88:double **make_matrix(int m, int n) {
        -:   89:  double **a;
        -:   90:  int i;
     3158:   91:  a = calloc(m, sizeof(double *));
   108177:   92:  for (i = 0; i < m; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   105019:   93:    a[i] = calloc(n, sizeof(double));
        -:   94:  }
     3158:   95:  return a;
        -:   96:}
        -:   97:
function scan_matrix called 0 returned 0% blocks executed 0%
    #####:   98:void scan_matrix(double **m, int row, int col) {
    #####:   99:  for (int i = 0; i < row; i++) {
branch  0 never executed
branch  1 never executed
    #####:  100:    for (int j = 0; j < col; j++) {
branch  0 never executed
branch  1 never executed
        -:  101:      // pr("i = %d, j = %d\n", i, j);
    #####:  102:      scanf("%lf", &m[i][j]);
call    0 never executed
        -:  103:    }
        -:  104:  }
    #####:  105:}
        -:  106:
function print_array called 0 returned 0% blocks executed 0%
    #####:  107:void print_array(double *array, int len) {
    #####:  108:  for (int i = 0; i < len; i++) {
branch  0 never executed
branch  1 never executed
        -:  109:    pr("%12.3lf", array[i]);
        -:  110:  }
        -:  111:  pr("\n");
    #####:  112:}
        -:  113:
function print_a_b called 0 returned 0% blocks executed 0%
    #####:  114:void print_a_b(double **a, double *b, int m, int n) {
    #####:  115:  for (int i = 0; i < m; i++) {
branch  0 never executed
branch  1 never executed
    #####:  116:    for (int j = 0; j < n; j++) {
branch  0 never executed
branch  1 never executed
        -:  117:      pr("%12.3lf", a[i][j]);
        -:  118:    }
        -:  119:    pr(" \u2264 %9.3lf\n", b[i]);
        -:  120:  }
    #####:  121:}
        -:  122:
function print_system called 0 returned 0% blocks executed 0%
    #####:  123:void print_system(double *c, double **a, double *b, int m, int n) {
        -:  124:  pr("%-12s", "max z =");
    #####:  125:  print_array(c, n);
call    0 never executed
    #####:  126:  print_a_b(a, b, m, n);
call    0 never executed
    #####:  127:}
        -:  128:
function free_node_full called 0 returned 0% blocks executed 0%
    #####:  129:void free_node_full(node_t* p) {
    #####:  130:        free(p->c);
    #####:  131:        free(p->b);
    #####:  132:        for (int i = 0; i < p->m; i++) {
branch  0 never executed
branch  1 never executed
    #####:  133:              free(p->a[i]);
        -:  134:        }
    #####:  135:        free(p->a);
    #####:  136:        free(p->x);
    #####:  137:        free(p->min);
    #####:  138:        free(p->max);
    #####:  139:        free(p);
    #####:  140:}
        -:  141:
function free_node_partial called 0 returned 0% blocks executed 0%
    #####:  142:void free_node_partial(node_t* p) {
    #####:  143:	free(p->min);
    #####:  144:	free(p->max);	
    #####:  145:	free(p);
    #####:  146:}
        -:  147:
function safe_free called 26671 returned 100% blocks executed 100%
    26671:  148:void safe_free(void **ptr) {
    26671:  149:    if (ptr != NULL && *ptr != NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 71% (fallthrough)
branch  3 taken 29%
    18825:  150:        free(*ptr);
    18825:  151:        *ptr = NULL; // Set the original pointer to NULL
        -:  152:    }
    26671:  153:}
        -:  154:
function free_node called 3118 returned 100% blocks executed 100%
     3118:  155:void free_node(node_t* p) {
     3118:  156:  safe_free((void **)&p->c);
call    0 returned 100%
     3118:  157:  safe_free((void **)&p->b);
call    0 returned 100%
     3118:  158:  if (p->a != NULL) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
    54002:  159:    for (int i = 0; i < p->m + 1; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
    52460:  160:      free(p->a[i]);
        -:  161:    }
     1542:  162:    free(p->a);
     1542:  163:    p->a = NULL;
        -:  164:  }
     3118:  165:  safe_free((void **)&p->a);
call    0 returned 100%
     3118:  166:  safe_free((void **)&p->x);
call    0 returned 100%
     3118:  167:  safe_free((void **)&p->min);
call    0 returned 100%
     3118:  168:  safe_free((void **)&p->max);
call    0 returned 100%
     3118:  169:  safe_free((void **)&p);
call    0 returned 100%
     3118:  170:}
        -:  171:
function init called 6301 returned 100% blocks executed 100%
     6301:  172:int init(simplex_t *s,
        -:  173:         int m,
        -:  174:         int n,
        -:  175:         double **a,
        -:  176:         double *b,
        -:  177:         double *c,
        -:  178:         double *x,
        -:  179:         double y,
        -:  180:         int *var) {
        -:  181:  int i, k;
     6301:  182:  s->m = m;
     6301:  183:  s->n = n;
     6301:  184:  s->a = a;
     6301:  185:  s->b = b;
     6301:  186:  s->c = c;
     6301:  187:  s->x = x;
     6301:  188:  s->y = y;
     6301:  189:  s->var = var;
     6301:  190:  if (s->var == NULL) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     3158:  191:    s->var = calloc(m + n + 1, sizeof(int));
   167932:  192:    for (i = 0; i < m + n; i++) {
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
   164774:  193:      s->var[i] = i;
        -:  194:    }
        -:  195:  }
   203589:  196:  for (k = 0, i = 1; i < m; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   197288:  197:    if (b[i] < b[k]) {
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
    35637:  198:      k = i;
        -:  199:    }
        -:  200:  }
     6301:  201:  return k;
        -:  202:}
        -:  203:
function select_nonbasic called 169492 returned 100% blocks executed 100%
   169492:  204:int select_nonbasic(simplex_t *s) {
        -:  205:  int i;
  1419040:  206:  for (i = 0; i < s->n; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
  1414273:  207:    if (s->c[i] > epsilon) {
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  208:      // pr("col = %d\n", i);
   164725:  209:      return i;
        -:  210:    }
        -:  211:  }
     4767:  212:  return -1;
        -:  213:}
        -:  214:
function prepare called 3143 returned 100% blocks executed 100%
     3143:  215:void prepare(simplex_t *s, int k) {
     3143:  216:  int m = s->m;
     3143:  217:  int n = s->n;
        -:  218:  int i;
        -:  219:  // make room for xm+n at s.var[n] by moving s.var[n..n+m-1] one
        -:  220:  // step to the right.
   104871:  221:  for (i = m + n; i > n; i--) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   101728:  222:    s->var[i] = s->var[i - 1];
        -:  223:  }
     3143:  224:  s->var[n] = m + n;
        -:  225:  // add xm+n to each constant
     3143:  226:  n = n + 1;
   104871:  227:  for (i = 0; i < m; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   101728:  228:    s->a[i][n - 1] = -1; // arrow?
        -:  229:  }
     3143:  230:  s->x = calloc(m + n, sizeof(double));
     3143:  231:  s->c = calloc(n, sizeof(double));
     3143:  232:  s->c[n - 1] = -1;
     3143:  233:  s->n = n;
     3143:  234:  pivot(s, k, n - 1);
call    0 returned 100%
     3143:  235:}
        -:  236:
function initial called 6301 returned 100% blocks executed 100%
     6301:  237:int initial(simplex_t *s,
        -:  238:            int m,
        -:  239:            int n,
        -:  240:            double **a,
        -:  241:            double *b,
        -:  242:            double *c,
        -:  243:            double *x,
        -:  244:            double y,
        -:  245:            int *var) {
        -:  246:  int i, j, k;
        -:  247:  double w;
     6301:  248:  k = init(s, m, n, a, b, c, x, y, var);
call    0 returned 100%
     6301:  249:  if (b[k] >= 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     3158:  250:    return 1; // feasible
        -:  251:  }
     3143:  252:  prepare(s, k);
call    0 returned 100%
     3143:  253:  n = s->n;
     3143:  254:  s->y = xsimplex(m, n, s->a, s->b, s->c, s->x, 0, s->var, 1);
call    0 returned 100%
   141489:  255:  for (i = 0; i < m + n; i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
   141489:  256:    if (s->var[i] == m + n - 1) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
     3142:  257:      if (fabs(s->x[i]) > epsilon) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
     1532:  258:        free(s->x);
     1532:  259:        free(s->c);
     1532:  260:        return 0;
        -:  261:      }
        -:  262:      else {
     1610:  263:        break;
        -:  264:      }
        -:  265:    }
        -:  266:  }
     1610:  267:  if (i >= n) {
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
    27676:  268:    for (j = k = 0; k < n; k++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    26418:  269:      if (fabs(s->a[i - n][k]) > fabs(s->a[i - n][j])) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
     2978:  270:        j = k;
        -:  271:      }
        -:  272:    }
     1258:  273:    pivot(s, i - n, j);
call    0 returned 100%
     1258:  274:    i = j;
        -:  275:  }
     1610:  276:  if (i < n - 1) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
     1580:  277:    k = s->var[i];
     1580:  278:    s->var[i] = s->var[n - 1];
     1580:  279:    s->var[n - 1] = k;
    51487:  280:    for (k = 0; k < m; k++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
    49907:  281:      w = s->a[k][n - 1];
    49907:  282:      s->a[k][n - 1] = s->a[k][i];
    49907:  283:      s->a[k][i] = w;
        -:  284:    }
        -:  285:  }
        -:  286:  else {
        -:  287:    // forget xn+m
        -:  288:  }
     1610:  289:  free(s->c);
     1610:  290:  s->c = c;
     1610:  291:  s->y = y;
    52442:  292:  for (k = n - 1; k < n + m - 1; k++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
    50832:  293:    s->var[k] = s->var[k + 1];
        -:  294:  }
     1610:  295:  n = s->n = s->n - 1;
     1610:  296:  double *t = calloc(n, sizeof(double));
    33758:  297:  for (k = 0; k < n; k++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
   566092:  298:    for (j = 0; j < n; j++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
   545045:  299:      if (k == s->var[j]) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
    11101:  300:        t[j] = t[j] + s->c[k];
    11101:  301:        goto next_k;
        -:  302:      }
        -:  303:    }
   337599:  304:    for (j = 0; j < m; j++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
   337599:  305:      if (s->var[n + j] == k) {
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
    21047:  306:        break;
        -:  307:      }
        -:  308:    }
    21047:  309:    s->y = s->y + s->c[k] * s->b[j];
   441901:  310:    for (i = 0; i < n; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
   420854:  311:      t[i] = t[i] - s->c[k] * s->a[j][i];
        -:  312:    }
    21047:  313:  next_k:
    32148:  314:    continue;
        -:  315:  }
    33758:  316:  for (i = 0; i < n; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    32148:  317:    s->c[i] = t[i];
        -:  318:  }
     1610:  319:  free(t);
     1610:  320:  free(s->x);
     1610:  321:  return 1;
        -:  322:}
        -:  323:
function pivot called 169126 returned 100% blocks executed 100%
   169126:  324:void pivot(simplex_t *s, int row, int col) {
        -:  325:  // pr("pivot row=%d col=%d\n", row, col);
   169126:  326:  double **a = s->a;
   169126:  327:  double *b = s->b;
   169126:  328:  double *c = s->c;
   169126:  329:  int m = s->m;
   169126:  330:  int n = s->n;
        -:  331:  int i, j, t;
   169126:  332:  t = s->var[col];
   169126:  333:  s->var[col] = s->var[n + row];
   169126:  334:  s->var[n + row] = t;
   169126:  335:  s->y = s->y + c[col] * b[row] / a[row][col];
  3704542:  336:  for (i = 0; i < n; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
  3535416:  337:    if (i != col) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
  3366290:  338:      c[i] = c[i] - c[col] * a[row][i] / a[row][col];
        -:  339:    }
        -:  340:  }
   169126:  341:  c[col] = -c[col] / a[row][col];
  5682453:  342:  for (i = 0; i < m; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
  5513327:  343:    if (i != row) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
  5344201:  344:      b[i] = b[i] - a[i][col] * b[row] / a[row][col];
        -:  345:    }
        -:  346:  }
  5682448:  347:  for (i = 0; i < m; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
  5513322:  348:    if (i != row) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
117080804:  349:      for (j = 0; j < n; j++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
111736607:  350:        if (j != col) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
106392411:  351:          a[i][j] = a[i][j] - a[i][col] * a[row][j] / a[row][col];
        -:  352:        }
        -:  353:      }
        -:  354:    }
        -:  355:  }
  5682409:  356:  for (i = 0; i < m; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
  5513283:  357:    if (i != row) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
  5344158:  358:      a[i][col] = -a[i][col] / a[row][col];
        -:  359:    }
        -:  360:  }
  3704521:  361:  for (i = 0; i < n; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
  3535395:  362:    if (i != col) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
  3366270:  363:      a[row][i] = a[row][i] / a[row][col];
        -:  364:    }
        -:  365:  }
   169126:  366:  b[row] = b[row] / a[row][col];
   169126:  367:  a[row][col] = 1 / a[row][col];
   169126:  368:}
        -:  369:
        -:  370:int simplex_i = 0;
        -:  371:
function print_simplex called 0 returned 0% blocks executed 0%
    #####:  372:void print_simplex(double** a, double* b, double* c, double* x, int* var, int m, int n) {
        -:  373:  pr("\n");
        -:  374:  pr("simplex %d\n", simplex_i);
        -:  375:  pr("maximize: %9.1lf x_%d + %9.1lf x_%d + XXX\n", c[0], var[0], c[1], var[1]);
        -:  376:  int i, j;
        -:  377:
        -:  378:  pr("subject to\n");
    #####:  379:  for (i = 0; i<m; i++){
branch  0 never executed
branch  1 never executed
        -:  380:    pr("      x_%d = %9.1lf - (", var[2], b[i]);
    #####:  381:    for (j=0; j<n; j++){
branch  0 never executed
branch  1 never executed
        -:  382:      pr("%9.1lf x_%d +", a[i][j], var[j]);
        -:  383:    }
        -:  384:    pr(")\n");
        -:  385:  }
    #####:  386:}
        -:  387:
function xsimplex called 6301 returned 100% blocks executed 97%
     6301:  388:double xsimplex(int m,
        -:  389:                int n,
        -:  390:                double **a,
        -:  391:                double *b,
        -:  392:                double *c,
        -:  393:                double *x,
        -:  394:                double y,
        -:  395:                int *var,
        -:  396:                int h) {
     6301:  397:  simplex_i ++;
        -:  398:	simplex_t s;
        -:  399:  int i, row, col;
     6301:  400:  if (!initial(&s, m, n, a, b, c, x, y, var)) {
call    0 returned 100%
branch  1 taken 24% (fallthrough)
branch  2 taken 76%
     1532:  401:    free(s.var);
     1532:  402:    return NAN;
        -:  403:  }
        -:  404:  //print_simplex(a, b, c, x, s.var, m, n);
   169492:  405:  while ((col = select_nonbasic(&s)) >= 0) {
call    0 returned 100%
branch  1 taken 97%
branch  2 taken 3% (fallthrough)
   164725:  406:    row = -1;
  5535198:  407:    for (i = 0; i < m; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
  5370473:  408:      if (a[i][col] > epsilon &&
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
branch  2 taken 94% (fallthrough)
branch  3 taken 6%
  2739680:  409:          (row < 0 || b[i] / a[i][col] < b[row] / a[row][col])) {
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
   555861:  410:        row = i;
        -:  411:      }
        -:  412:    }
   164725:  413:    if (row < 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  414:      free(s.var);
    #####:  415:      return INFINITY;
        -:  416:    }
   164725:  417:    pivot(&s, row, col);
call    0 returned 100%
        -:  418:    //print_simplex(a, b, c, x, s.var, m, n);
        -:  419:    // pr("PIVOTED");
        -:  420:    // print_system(c, a, b, m, n);
        -:  421:  }
     4767:  422:  if (h == 0) {
branch  0 taken 34% (fallthrough)
branch  1 taken 66%
    33896:  423:    for (i = 0; i < n; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    32271:  424:      if (s.var[i] < n) {
branch  0 taken 34% (fallthrough)
branch  1 taken 66%
    11078:  425:        x[s.var[i]] = 0;
        -:  426:      }
        -:  427:    }
    52590:  428:    for (i = 0; i < m; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
    50965:  429:      if (s.var[n + i] < n) {
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
    21193:  430:        x[s.var[n + i]] = s.b[i];
        -:  431:      }
        -:  432:    }
     1625:  433:    free(s.var);
        -:  434:  }
        -:  435:  else {
    69054:  436:    for (i = 0; i < n; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    65912:  437:      x[i] = 0;
        -:  438:    }
   104826:  439:    for (i = n; i < n + m; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
   101684:  440:      x[i] = s.b[i - n];
        -:  441:    }
        -:  442:  }
        -:  443:  // free(s.x);
        -:  444:  // free(s.c);
        -:  445:  // pr("Found z = %9.1lf\n", s.y);
        -:  446:  // pr("------------------------------------");
     4767:  447:  return s.y;
        -:  448:}
        -:  449:
        -:  450:double
function simplex called 3158 returned 100% blocks executed 100%
     3158:  451:simplex(int m, int n, double **a, double *b, double *c, double *x, double y) {
     3158:  452:  return xsimplex(m, n, a, b, c, x, y, NULL, 0);
call    0 returned 100%
        -:  453:}
        -:  454:
function initial_node called 9 returned 100% blocks executed 100%
        9:  455:node_t *initial_node(int m, int n, double **a, double *b, double *c) {
        9:  456:  node_t *p = calloc(1, sizeof(node_t));
        9:  457:  p->a = make_matrix(m + 1, n + 1);
call    0 returned 100%
        9:  458:  p->b = calloc(m + 1, sizeof(double));
        9:  459:  p->c = calloc(n + 1, sizeof(double));
        9:  460:  p->x = calloc(n + 1, sizeof(double));
        9:  461:  p->min = calloc(n, sizeof(double));
        9:  462:  p->max = calloc(n, sizeof(double));
        9:  463:  p->m = m;
        9:  464:  p->n = n;
        9:  465:  p->next = NULL;
        -:  466:
        -:  467:  int i;
       57:  468:  for (i = 0; i <= m; i++) {
branch  0 taken 84%
branch  1 taken 16% (fallthrough)
       48:  469:    memcpy(p->a[i], a[i],
       48:  470:           (n + 1) * sizeof(double)); // Todo, very unsure (n+1??)
        -:  471:  }
        -:  472:
        9:  473:  memcpy(p->b, b, (m) * sizeof(double)); // Todo, Should it be +1?
        9:  474:  memcpy(p->c, c, (n + 1) * sizeof(double));
       48:  475:  for (i = 0; i < n; i++) {
branch  0 taken 81%
branch  1 taken 19% (fallthrough)
       39:  476:    p->min[i] = -INFINITY;
       39:  477:    p->max[i] = INFINITY;
        -:  478:  }
        9:  479:  return p;
        -:  480:}
        -:  481:
function extend called 3149 returned 100% blocks executed 100%
     3149:  482:node_t *extend(node_t *p,
        -:  483:               int m,
        -:  484:               int n,
        -:  485:               double **a,
        -:  486:               double *b,
        -:  487:               double *c,
        -:  488:               int k,
        -:  489:               double ak,
        -:  490:               double bk) {
     3149:  491:  node_t *q = calloc(1, sizeof(node_t));
        -:  492:  int i, j;
     3149:  493:  q->k = k;
     3149:  494:  q->ak = ak;
     3149:  495:  q->bk = bk;
     3149:  496:  if (ak > 0 && p->max[k] < INFINITY) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 39% (fallthrough)
branch  3 taken 61%
      619:  497:    q->m = p->m;
        -:  498:  }
     2530:  499:  else if (ak < 0 && p->min[k] > 0) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
branch  2 taken 26% (fallthrough)
branch  3 taken 74%
      417:  500:    q->m = p->m;
        -:  501:  }
        -:  502:  else {
     2113:  503:    q->m = p->m + 1;
        -:  504:  }
     3149:  505:  q->n = p->n;
     3149:  506:  q->h = -1;
     3149:  507:  q->a = make_matrix(q->m + 1, q->n + 1);
call    0 returned 100%
     3149:  508:  q->b = calloc(q->m + 1, sizeof(double));
     3149:  509:  q->c = calloc(q->n + 1, sizeof(double));
     3149:  510:  q->x = calloc(q->n + 1, sizeof(double));
     3149:  511:  q->min = calloc(n, sizeof(double));
     3149:  512:  q->max = calloc(n, sizeof(double));
        -:  513:  // Memcopy(dest, src, count)
     3149:  514:  memcpy(q->min, p->min, n * sizeof(double)); // TODO, ensure this
     3149:  515:  memcpy(q->max, p->max, n * sizeof(double));
    66023:  516:  for (i = 0; i < m; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    62874:  517:    memcpy(q->a[i], a[i], (n + 1) * sizeof(double)); // still unsure
        -:  518:  }
     3149:  519:  memcpy(q->b, b, m * sizeof(double_t));
     3149:  520:  memcpy(q->c, c, (n + 1) * sizeof(double_t)); // n+1?
        -:  521:  // TODO copying
     3149:  522:  if (ak > 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     1575:  523:    if (q->max[k] == INFINITY || bk < q->max[k]) {
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     1575:  524:      q->max[k] = bk;
        -:  525:    }
        -:  526:  }
     1574:  527:  else if (q->min[k] == -INFINITY || -bk > q->min[k]) {
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
     1574:  528:    q->min[k] = -bk;
        -:  529:  }
    66023:  530:  for (i = m, j = 0; j<n; j++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
    62874:  531:    if (q->min[j] > -INFINITY) {
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
    18229:  532:      q->a[i][j] = -1;
    18229:  533:      q->b[i] = -q->min[j];
    18229:  534:      i++;
        -:  535:    }
    62874:  536:    if (q->max[j] < INFINITY) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
    20719:  537:      q->a[i][j] = 1;
    20719:  538:      q->b[i] = q->max[j];
    20719:  539:      i++;
        -:  540:    }
        -:  541:  }
     3149:  542:  return q;
        -:  543:}
        -:  544:
function is_integer called 23824 returned 100% blocks executed 100%
    23824:  545:int is_integer(double *xp) {
    23824:  546:  double x = *xp;
    23824:  547:  double r = round(x);
    23824:  548:  if (fabs(r - x) < epsilon) {
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
    20593:  549:    *xp = r;
    20593:  550:    return 1;
        -:  551:  }
        -:  552:  else {
     3231:  553:    return 0;
        -:  554:  }
        -:  555:}
        -:  556:
function integer called 1630 returned 100% blocks executed 100%
     1630:  557:int integer(node_t *p) {
        -:  558:  int i;
    11952:  559:  for (i = 0; i < p->n; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
    11938:  560:    if (!is_integer(&p->x[i])) {
call    0 returned 100%
branch  1 taken 14% (fallthrough)
branch  2 taken 86%
     1616:  561:      return 0;
        -:  562:    }
        -:  563:  }
       14:  564:  return 1;
        -:  565:}
        -:  566:
function bound called 4 returned 100% blocks executed 100%
        4:  567:void bound(node_t *p, linked_nodes_t* h, double *zp, double* x) {
        4:  568:  if (p->z > *zp) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  569:    *zp = p->z;
        4:  570:    memcpy(x, p->x, p->n * sizeof(double)); //todo unsure?
        -:  571:    linked_nodes_t rinsed_nodes; // = calloc(1, sizeof(linked_nodes_t));
        4:  572:    rinsed_nodes.head = NULL;
        -:  573:    node_t* q;
       25:  574:    while (h->head != NULL){
branch  0 taken 84%
branch  1 taken 16% (fallthrough)
       21:  575:        q = pop(h);
call    0 returned 100%
       21:  576:        if(q->z >= p->z) {
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
       19:  577:            push(&rinsed_nodes, q);
call    0 returned 100%
        -:  578:        }
        -:  579:        else {
        -:  580:          //free(q);
        2:  581:	        free_node(q);
call    0 returned 100%
        -:  582:        }
        -:  583:    }
        4:  584:    h->head = rinsed_nodes.head;
        -:  585:  }
        4:  586:}
        -:  587:
function branch called 1616 returned 100% blocks executed 92%
     1616:  588:int branch(node_t *q, double z) {
        -:  589:  double min, max;
        -:  590:  int h;
     1616:  591:  if (q->z < z) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        1:  592:    return 0;
        -:  593:  }
    11886:  594:  for (h = 0; h < q->n; h++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
    11886:  595:    if (!is_integer(&q->x[h])) {
call    0 returned 100%
branch  1 taken 14% (fallthrough)
branch  2 taken 86%
     1615:  596:      if (q->min[h] == -INFINITY) {
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
     1195:  597:        min = 0;
        -:  598:      }
        -:  599:      else {
      420:  600:        min = q->min[h];
        -:  601:      }
     1615:  602:      max = q->max[h];
     1615:  603:      if (floor(q->x[h]) < min || ceil(q->x[h]) > max) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  604:        continue;
        -:  605:      }
     1615:  606:      q->h = h;
     1615:  607:      q->xh = q->x[h];
        -:  608:      //todo ensure frees
     1615:  609:      if (q->a != NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    54129:  610:        for (int i = 0; i < q->m+1; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
    52514:  611:                free(q->a[i]);
        -:  612:        }
     1615:  613:        free(q->a);
     1615:  614:        q->a = NULL;
        -:  615:      }
        -:  616:      //safe_free((void **)&q->a);
     1615:  617:      safe_free((void **)&q->b);
call    0 returned 100%
     1615:  618:      safe_free((void **)&q->c);
call    0 returned 100%
     1615:  619:      safe_free((void **)&q->x);
call    0 returned 100%
     1615:  620:      return 1;
        -:  621:    }
        -:  622:  }
    #####:  623:  return 0;
        -:  624:}
        -:  625:
function succ called 3149 returned 100% blocks executed 93%
     3149:  626:void succ(node_t *p,
        -:  627:          linked_nodes_t *h,
        -:  628:          int m,
        -:  629:          int n,
        -:  630:          double **a,
        -:  631:          double *b,
        -:  632:          double *c,
        -:  633:          int k,
        -:  634:          double ak,
        -:  635:          double bk,
        -:  636:          double *zp,
        -:  637:          double *x) {
     3149:  638:  node_t *q = extend(p, m, n, a, b, c, k, ak, bk);
call    0 returned 100%
     3149:  639:  if (q == NULL) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  640:    return;
        -:  641:  }
     3149:  642:  q->z = simplex(q->m, q->n, q->a, q->b, q->c, q->x, 0);
call    0 returned 100%
     3148:  643:  if (isfinite(q->z)) {
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
     1616:  644:    if (integer(q)) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 100%
        4:  645:        bound(q, h ,zp, x);
call    0 returned 100%
        -:  646:    }
     1612:  647:    else if (branch(q, *zp)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 1%
     1611:  648:        push(h, q);
call    0 returned 100%
     1611:  649:        return;
        -:  650:    }
        -:  651:  }
        -:  652:  //free(q->min);
        -:  653:  //free(q->max);
     1537:  654:  free_node(q);
call    0 returned 100%
        -:  655:}
        -:  656:
function intopt called 9 returned 89% blocks executed 96%
        9:  657:double intopt(int m, int n, double **a, double *b, double *c, double *x) {
        9:  658:  node_t *p = initial_node(m, n, a, b, c);
call    0 returned 100%
        -:  659:  linked_nodes_t h;
        9:  660:  h.head = NULL;
        9:  661:  push(&h, p);
call    0 returned 100%
        9:  662:  double z = -INFINITY;
        9:  663:  p->z = simplex(p->m, p->n, p->a, p->b, p->c, p->x, 0);
call    0 returned 100%
        9:  664:  if (integer(p) || !isfinite(p->z)) {
call    0 returned 100%
branch  1 taken 44% (fallthrough)
branch  2 taken 56%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        5:  665:    z = p->z;
        5:  666:    if (integer(p)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        5:  667:      memcpy(x, p->x, (n + 1) * sizeof(double));
        -:  668:    }
        5:  669:    free_node(p);
call    0 returned 100%
        5:  670:    return z;
        -:  671:  }
        4:  672:  branch(p, z);
call    0 returned 100%
     1578:  673:  while (h.head != NULL) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     1575:  674:    p = pop(&h);
call    0 returned 100%
     1575:  675:    succ(p, &h, m, n, a, b, c, p->h, 1, floor(p->xh), &z, x);
call    0 returned 100%
     1574:  676:    succ(p, &h, m, n, a, b, c, p->h, -1, -ceil(p->xh), &z, x);
call    0 returned 100%
     1574:  677:    free_node(p);
call    0 returned 100%
        -:  678:  }
        -:  679:
        3:  680:  if (z == -INFINITY) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  681:    return NAN;
        -:  682:  }
        -:  683:  else {
        3:  684:    return z;
        -:  685:  }
        -:  686:}
        -:  687:
        -:  688:#if MAIN
        -:  689:int main(int argc, char **argv) {
        -:  690:   int m, n;
        -:  691:   scanf("%d %d", &m, &n);
        -:  692:   double *c = calloc(n + 1, sizeof(double));
        -:  693:   scan_vector(c, n);
        -:  694:
        -:  695:   double **a = make_matrix(m, n + 1);
        -:  696:   scan_matrix(a, m, n);
        -:  697:
        -:  698:   double *b = calloc(m, sizeof(double));
        -:  699:   scan_vector(b, m);
        -:  700:
        -:  701:   double *x = calloc(n + 1, sizeof(double));
        -:  702:
        -:  703:   double z = 0.0;
        -:  704:
        -:  705:   // print stuff
        -:  706:   pr("%-12s", "max z =");
        -:  707:   print_array(c, n);
        -:  708:   print_a_b(a, b, m, n);
        -:  709:
        -:  710:    //double y = 0;
        -:  711:    //y = simplex(m, n, a, b, c, x, y);
        -:  712:    //printf("result. y = %f\n", y);   
        -:  713:    z = intopt(m, n, a, b, c, x);   
        -:  714:    printf("result. z = %f\n", z);
        -:  715:
        -:  716:   // print_system(c, a, b, m, n);
        -:  717:
        -:  718:   free(c);
        -:  719:   free(b);
        -:  720:   for (int i = 0; i < m; i++) {
        -:  721:     free(a[i]);
        -:  722:   }
        -:  723:   free(a);
        -:  724:   free(x);
        -:  725:
        -:  726:   return 0;
        -:  727: }
        -:  728:#endif
